rm(list = ls())
library(boostvar)
library(vars)
#setwd("C:/Users/xhuang3/Documents/My Economics/Research/hdvar/program/testpkg")
load("C:/Users/xhuang3/Documents/My Economics/Research/hdvar/program/testpkg/fred.Rda")

###############################
# Test boostvar_group function.
###############################

# p = 2
# datay = fred[1:(20 + p),1:3]
# a = boostvar_group(datay, p = p, bstop = 5, nu = 0.1) #demean = TRUE)
# a$min_list
# a$p_mat
# plot(a$aic)
# 
# library(vars)
# b = VAR(datay, p = p, type = "const")
# b$varresult

# check the package boostvar obj.
#b = boostvar(datay, p = p, bstop = 5, nu = 0.1, group.type = 1, intercept = FALSE)

## Test boostvar_standard.
# p = 2
# datay = fred[1:(20 + p),1:3]
# a = boostvar_standard(datay, p = p, bstop = 5, nu = 0.1, demean = TRUE)
# a$min_list
# a$p_mat
# plot(a$aic)

## Test boost_original.
# p = 2
# datay = fred[1:(20 + p),1:3]
# a = boostvar_original(datay, p = p, bstop = 5, nu = 0.1, demean = TRUE)
# a$min_list
# a$p_mat
# plot(a$aic)


# Check VAR(1) for coefficient estimation.
# Results are OK, consistent with the vars package.
# set.seed(123)
# p = 1
# d = 2
# nobs = 200
# y = matrix(0, nobs, d)
# b0 = matrix(c(0.02,0.03),2,1)
# b1 = matrix(c(0.5,0.4,0.1,0.5),2,2)
# b2 = matrix(c(0,0.25,0,0),2,2)
# for (i in 3:dim(y)[1]) {
#   # y[i,] = t(b0) + t(b1 %*%  y[i-1,]) + t(b2 %*% y[i-2,]) +
#   #   c(rnorm(1,0,0.3), rnorm(1,0,0.2))
#   y[i,] = t(b0) + t(b1 %*%  y[i-1,]) +
#     c(rnorm(1,0,0.3), rnorm(1,0,0.2))
# }
# 
# y = tail(y,-98)
# a = boostvar(y, p = p, bstop = 100, nu = 0.1)
# a$min_list
# a$beta_mat
# 
# b = VAR(y, p = 1, type = "const")
# b$varresult



# Check VAR(2). 
# Results are OK, consistenty with the vars package.
# set.seed(123)
# p = 2
# d = 2
# nobs = 200
# y = matrix(0, nobs, d)
# b0 = matrix(c(0.02,0.03),2,1)
# b1 = matrix(c(0.5,0.4,0.1,0.5),2,2)
# b2 = matrix(c(0,0.25,0,0),2,2)
# for (i in 3:dim(y)[1]) {
#   y[i,] = t(b0) + t(b1 %*%  y[i-1,]) + t(b2 %*% y[i-2,]) +
#     c(rnorm(1,0,0.3), rnorm(1,0,0.2))
#   # y[i,] = t(b0) + t(b1 %*%  y[i-1,]) +
#   #   c(rnorm(1,0,0.3), rnorm(1,0,0.2))
# }
# 
# y = tail(y,-98)
# a = boostvar_group(y, p = p, bstop = 500, nu = 0.01) #demean = TRUE)
# a$min_list
# a$beta_mat
# 
# # Reshape the results.
# step = 500
# print("boosting betas")
# cbind(t((a$beta_mat)[,,1,step])[,1],t((a$beta_mat)[,,2,step])[,1],t((a$beta_mat)[,,1,step])[,2],t((a$beta_mat)[,,2,step])[,2])
# cbind(t((a$p_mat)[,,1,step])[,1],t((a$p_mat)[,,2,step])[,1],t((a$p_mat)[,,1,step])[,2],t((a$p_mat)[,,2,step])[,2])
# 
# cbind(b1,b2)
# 
# b = VAR(y, p = p, type = "const")
# b$varresult



# Use the DGP on page 137 of New Introduction to Multiple Time Series.
# set.seed(123)
# p = 2
# d = 2
# nobs = 400
# y = matrix(0, nobs, d)
# b0 = matrix(c(0.02,0.03),2,1)
# b1 = matrix(c(0.5,0.4,0.1,0.5),2,2)
# b2 = matrix(c(0,0.25,0,0),2,2)
# for (i in 3:dim(y)[1]) {
#   y[i,] = t(b0) + t(b1 %*%  y[i-1,]) + t(b2 %*% y[i-2,]) +
#     c(rnorm(1,0,0.3), rnorm(1,0,0.2))
# }
# 
# y = tail(y,-98)
# a = boostvar(y, p = p, bstop = 100, nu = 0.1)
# a$min_list
# a$beta_mat
# 
# library(vars)
# b = VAR(y, p = 2, type = "const")
# b$varresult

######################################
# Test the boostvar_standard function.
######################################

# a = boostvar_standard(datay, p = p, bstop = 5, nu = 0.1, demean = TRUE)

# Check VAR(2) with boostbar_standard, same as the boost_single function.
# Results are OK, consistent with the vars package.
set.seed(123)
p = 2
d = 2
nobs = 200
bstop = 200
y = matrix(0, nobs, d)
b0 = matrix(c(0.02,0.03),2,1)
b1 = matrix(c(0.5,0.4,0.1,0.5),2,2)
b2 = matrix(c(0,0.25,0,0),2,2)
for (i in 3:dim(y)[1]) {
  y[i,] = t(b0) + t(b1 %*%  y[i-1,]) + t(b2 %*% y[i-2,]) +
    c(rnorm(1,0,0.3), rnorm(1,0,0.2))
  # y[i,] = t(b0) + t(b1 %*%  y[i-1,]) +
  #   c(rnorm(1,0,0.3), rnorm(1,0,0.2))
}

y = tail(y,-98)
#a = boostvar_standard(y, p = p, bstop = bstop, nu = 0.1, demean = TRUE)
# boost_single is the same as boost_standard. Just a name change.
# a = boostvar_single(y, p = p, bstop = bstop, nu = 0.1) # demean = TRUE)
a = boostvar(y, p = p, bstop = bstop, nu = 0.1, group.type = 1)
a$min_list
a$beta_mat

step = bstop
cbind((a$beta_mat)[,,1,step],(a$beta_mat)[,,2,step])
cbind((a$p_mat)[,,1,step],(a$p_mat)[,,2,step])
cbind(b1,b2)


b = VAR(y, p = p, type = "const")
b$varresult


# Check VAR(2) with boost_each.
# The p-value not quite right. Needs double check on thce boost_each code.
# 2022-7-19.

# set.seed(123)
# p = 2
# d = 2
# nobs = 200
# bstop = 200
# y = matrix(0, nobs, d)
# b0 = matrix(c(0.02,0.03),2,1)
# b1 = matrix(c(0.5,0.4,0.1,0.5),2,2)
# b2 = matrix(c(0,0.25,0,0),2,2)
# for (i in 3:dim(y)[1]) {
#   y[i,] = t(b0) + t(b1 %*%  y[i-1,]) + t(b2 %*% y[i-2,]) +
#     c(rnorm(1,0,0.3), rnorm(1,0,0.2))
#   # y[i,] = t(b0) + t(b1 %*%  y[i-1,]) +
#   #   c(rnorm(1,0,0.3), rnorm(1,0,0.2))
# }
# 
# y = tail(y,-98)
# a = boostvar_each(y, p = p, bstop = bstop, nu = 0.01, demean = TRUE)
# a$min_list
# a$beta_mat
# # set.seed(123)
# p = 2
# d = 2
# nobs = 200
# bstop = 200
# y = matrix(0, nobs, d)
# b0 = matrix(c(0.02,0.03),2,1)
# b1 = matrix(c(0.5,0.4,0.1,0.5),2,2)
# b2 = matrix(c(0,0.25,0,0),2,2)
# for (i in 3:dim(y)[1]) {
#   y[i,] = t(b0) + t(b1 %*%  y[i-1,]) + t(b2 %*% y[i-2,]) +
#     c(rnorm(1,0,0.3), rnorm(1,0,0.2))
#   # y[i,] = t(b0) + t(b1 %*%  y[i-1,]) +
#   #   c(rnorm(1,0,0.3), rnorm(1,0,0.2))
# }
# 
# y = tail(y,-98)
# a = boostvar_each(y, p = p, bstop = bstop, nu = 0.01, demean = TRUE)
# a$min_list
# a$beta_mat
# 
# step = bstop
# cbind((a$beta_mat)[,,1,step],(a$beta_mat)[,,2,step])
# cbind((a$p_mat)[,,1,step],(a$p_mat)[,,2,step])
# cbind(b1,b2)
# 
# 
# b = VAR(y, p = p, type = "const")
# b$varresult
# step = bstop
# cbind((a$beta_mat)[,,1,step],(a$beta_mat)[,,2,step])
# cbind((a$p_mat)[,,1,step],(a$p_mat)[,,2,step])
# cbind(b1,b2)
# 
# 
# b = VAR(y, p = p, type = "const")
# b$varresult