% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/boostvar.R
\name{boostvar}
\alias{boostvar}
\title{p-Values for least-squares boosting in high-dimensional VARs}
\usage{
boostvar(
  datay,
  p = 1,
  bstop = 50,
  n_lambda = 50,
  nu = 0.1,
  group.type = 1,
  intercept = FALSE
)
}
\arguments{
\item{datay}{An n by d matrix of variables with n observations and d variables.
n is the number of time periods in the data, where the first row gives the
first observation and the last row includes the most recent observation.}

\item{p}{A positive integer for the lag of VAR. Defaults to 1.}

\item{bstop}{The number of boosting steps. Defaults to 50.}

\item{n_lambda}{The number of equally spaced boosting steps on the sequence from \code{1}
to \code{bstop}. This number needs to be smaller than or equal to \code{bstop}. One can
simply set it equal to \code{bstop}. Defaults to 50.}

\item{nu}{The learning rate. Defaults to 0.1.}

\item{group.type}{Specify the type of LS-Boost procedure. Options \code{1} and \code{2}
refer to the LS-Boost1 and LS-Boost2 methods in Huang (2022), respectively. Defaults
to 1.}

\item{intercept}{A logical value for whether to add intercept in the prediction function.
The two LS-Boost methods always estimate the intercept. The logical value of
\code{intercept} only affects the prediction function. Defaults to TRUE.}
}
\value{
\code{boostvar} returns a S3 class "boostvar" with the following components:
\item{y}{the n by d matrix of y on the l.h.s. of the
equation in the multivariate regression format.} \item{x}{the \eqn{n*pd} matrix of x on
the r.h.s. of the equation in the multivariate regression format. It consists of p
blocks of \eqn{n * d} matrices. Each \eqn{n * d} matrix includes the d variables at lag p.}
\item{n}{the sample size} \item{d}{the number of variables in the VAR} \item{p}{the
lag of the VAR model} \item{bstop}{the number of boosting steps} \item{nlam}{the
value of \code{n_lambda}} \item{beta}{an array of dimension \eqn{d * d * p * bstop} that
stores, for each boosting step, the \eqn{d*d} coefficient matrix for each of the lag. If
the value of a parameter estimate is 0 at a given boosting step, it means that parameter
has not been updated up to that step.}
\item{beta0}{a \eqn{d * bstop} matrix that stores the \eqn{d * 1} vector of intercept for
each boosting step} \item{se}{an array of dimension \eqn{d * d * p * bstop} that
stores, for each boosting step, the \eqn{d*d} standard error matrix for each of the lag.
If the value of a se is 0 at a given boosting step, it means the corresponding parameter
has not been updated up to that step.}
\item{pval}{an array of dimension \eqn{d * d * p * bstop} that
stores, for each boosting step, the \eqn{d*d} p-value matrix for each of the lag. If the
p-value is 1 at a given step, the corresponding parameter has not been updated up to
that boosting step.} \item{pval_stacked}{a \eqn{pd * d} matrix of p-values, rearranging
the values in \code{pval}. The shape of this matrix matches the \eqn{pd * d} parameter
matrix in the multivariate regression format of a VAR. Each element of this matrix
gives the p-value for the corresponding parameter in the following equation:
\deqn{Y = X\phi+u.}} \item{intercept}{the \code{intercept} logical variable}
\item{step_mat}{the matrix that records which variable is updated at each boosting step.
For the method with \code{group.type=1}, it is a \eqn{d * bstop} matrix. For the method
with \code{group.type=2}, it is a \eqn{d^2 * bstop} matrix.} \item{aic}{a sequence of
Akaike information criterion value for each boosting step}
}
\description{
This function computes the p-value for the two LS-Boost algorithms
discussed in Huang (2022).
}
\details{
This is the main function of the package. It returns parameter estimates,
standard errors, and p-values for all selected variables at every boosting step.
}
\examples{
 
  \dontrun{
  # An example of bivariate vector autoregression
  library(boostvar)
  set.seed(123)
  p = 2
  d = 2
  nobs = 100
  bstop = 50
  y = matrix(0, nobs, d)
  b0 = matrix(c(0.02,0.03),2,1)
  b1 = matrix(c(0.5,0.4,0.1,0.5),2,2)
  b2 = matrix(c(0,0.25,0,0),2,2)
  for (i in 3:dim(y)[1]) {
    y[i,] = t(b0) + t(b1 \%*\%  y[i-1,]) + t(b2 \%*\% y[i-2,]) +
      c(rnorm(1,0,0.3), rnorm(1,0,0.2))
  }
  y = tail(y,-p)
  result1 = boostvar(y, p = p, bstop = bstop, nu = 0.1, group.type = 1, intercept = TRUE)
  result2 = boostvar(y, p = p, bstop = bstop, nu = 0.1, group.type = 2, intercept = TRUE)
  }

}
